# 文件简介

## **Bash 脚本：**

这些脚本是启动多个代理在独立线程中的快捷方式

• **start.sh**-启动11个独立的**Run Player**实例，每个实例初始化1个**Agent**

• **start_debug.sh**-与前述相同，但每个**Run Player**在调试模式下初始化1个**Agent**

• **start_fat_proxy.sh**-启动11个Run Player实例，每个实例在**fat proxy**模式下初始化1个**Agent**

• **start_fat_proxy_debug.sh**-与前述相同，但每个Run Player也在调试模式下启动

• **start_penalty.sh**-启动11个Run Player实例，每个实例初始化1个罚球代理

• **start_penalty_debug.sh**-与前述相同，但每个Run Player在调试模式下初始化1个罚球代理

• **kill.sh**-杀死任何Main Python Scripts的实例

## **主Python脚本：**

• **Run_Utils.py**-交互式菜单运行：

• **Run_Player.py**-根据输入参数创建1个代理或罚球代理，在正常模式或调试模式下，然后无限循环运行选定的代理。

• **Run_Full_Team.py**-在同一线程中创建11个代理，并顺序运行每个代理，无限循环。由于它们都在1个线程上运行，可能会慢，但有助于调试。

• **Run_One_vs_One.py**-创建2个代理，每个团队1个，并在无限循环中运行两者。

## Agent文件夹

• **Base_Agent**-实现一个自动处理来自服务器的信息以更新其内部世界模型的代理。它集成了许多自动化程序的工具，创建了一个高级接口来与机器人和环境交互。调试模式在初始化期间显示额外信息，启用日志、绘图和通过服务器监控端口发送的特殊命令（例如将玩家传送至3D位置、杀死服务器、移动球、设置游戏时间、设置比赛模式、杀死任何代理）。

• **Agent (Agent.py)**-实现主要代理策略，用于实际足球比赛。该策略目前用于Fat Proxy Challenge，通过将本地命令转换为胖代理命令。然而，如果用户想要为 主要比赛和挑战使用不同的代理，我们建议复制Agent.py并命名为Agent_Fat_Proxy.py，并修改两个文件以删除不必要的组件。然后，调整Run_Player.py以根据“a.F”参数调用适当的代理类，就像使用“a.P”调用罚球代理一样。

• **Agent (Agent_Penalty.py)**-实现点球大战期间使用的主要策略。它控制守门员和一名射手。

## Behaviors文件夹

• **Behavior**-管理低级行为，在检测到过渡时自动重置它们

• **Head**-控制机器人头部方向的算法

• **Poses**-一个姿势由单个关键帧定义（每个关节1个角度位置）

• **Slot_Engine**-管理槽行为的执行

• **Behavior**-管理低级行为，在检测到过渡时自动重置它们

### custom文件夹

• **Custom skills**-需要自定义准备和/或执行的技能

### slot文件夹

定义由多个关键帧组成的行为的XML文件

## Bundle文件夹

多个文件或资源打包

## communication文件夹

• **Radio**-自动化内部通信，与队友共享每个可见代理和球的位置与状态

• **Server_Comm**-通过官方代理端口（初始化、机器人关节速度、队友消息、传球命令和传送）和非官方监控端口（将玩家传送至3D位置、杀死服务器、移动球、设置游戏时间、设置比赛模式、杀死任何代理）处理与服务器的所有通信；

• **World_Parser**-自定义S表达式解析器，用于服务器消息，通过重映射某些轴来标准化参考框架。此外，一些关节被反转，使得与左肢执行的动作与右肢执行的动作镜像（允许更容易地指定对称行为）；

## `cpp`文件夹

• **a_star.so**-自定义A路径查找实现库，用C++优化足球环境。定义2种类型的障碍物：

​		• 静态障碍物，如球门柱和外场线（球员在正常行走时可以穿过，但在运球时不能）；

​		• 动态障碍物，如球员、球和某些比赛模式中定义的排除区域。每个障碍物都可以与硬排除半径相关联，定义严格禁止的区域，和/或软排除半径，指定要避免的区域。软排除区的避免强度是可配置的。

• **ball_predictor.so**-自定义C++库，用于预测滚动球（在地面上）的位置和速度。它还预测机器人在特定行走速度下何时会与滚动球相交。

• **localization.so**-基于自定义概率模型的6D姿态估计算法（详细算法解释请参见6D定位论文）。*

## log文件夹

• **Logger**-日志记录对象链接到特定主题，负责时间戳和保存日志文件中的消息（错误、警告或任何有用的信息）；

## scripts文件夹

### commons文件夹



### gyms文件夹



### utils文件夹

**实用工具**

**传送（Beam）**

将玩家传送到特定的坐标，并改变其方向，方向范围在 -180 到 180 度之间。

 **行为（Behaviors）**

交互式测试所有行为，包括自动加载的基于 XML 的新技能。

**绘图（Drawings**）

展示绘图功能。

**盘球（Dribble）**

使用盘球技巧得分。

**正向运动学（Forward Kinematics）**

使用正向运动学和视觉进行自我定位，获取身体部位和关节的绝对位置，以及身体部位的3D方向。

**起身（Get-Up）**

在不同条件下测试起身行为。

**惯性测量单元（IMU）**

使用惯性测量单元（加速度计+磁力计）的例子。对于方向来说，它是准确的。对于平移，由于累积误差，应避免使用。（参见 `world/Robot.py` 中的 `loc` 和 `imu` 变量）

**踢球（Kick）**

机器人将向场地中心踢球。

**定位（Localization）**

这个演示绘制了代理在其有限视野范围内能感知到的环境，包括场地线、球门柱、角旗、队友、对手和球。

**路径寻找（Pathfinding）**

展示围绕虚拟障碍物的路径寻找，包括两条路线：一条从代理到球，允许出界移动；另一条从球到代理，限制在界内。

**无线电定位（Radio Localization）**

- 绿色线条表示视野范围内的球员/球。

- 黄色线条表示通过队友通信已知的球员/球位置。

- 红色线条将表示未知位置（即通信失败）。

## world文件夹

- **world**:内部世界模型，通过视觉和与队友的通信进行更新。它监控各种时间指标，例如比赛时间、服务器时间和客户端时间，同时还捕捉比赛状态和动态对象，包括自身、队友、对手和球。它具有计算相对和绝对球速的方法（在给定时间窗口内），以及操作位置预测的方法。其主要类包括：

- **Robot**：内部机器人状态，包括关于定位、方向、关节、关节目标、身体部件和传感器的信息。提供处理关节控制、IMU 计算、正向运动学和姿态变换（3D 平移和方向）的方法；

  ### commits文件夹

- **Draw**：用于在 `RoboViz` 上绘图的类。它除了绘制所有原生形状和文本注释外，还可以绘制箭头。此类可以通过世界对象访问，也可以独立于代理创建，如在 Draw 工具中所见。

- **Other_Robot**：关于队友或对手状态的信息。

- **robots**：包含 5 种机器人模型规格的 XML 文件。
  
  

s
